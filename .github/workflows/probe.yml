# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
    secrets:
      PROBE_CHAT_COMMAND:
        required: false
        description: "Optional command for probe chat"
      ANTHROPIC_API_KEY:
        required: false
        description: "API key for Anthropic service"
      OPENAI_API_KEY:
        required: false
        description: "API key for OpenAI service"
      GOOGLE_API_KEY:
        required: false
        description: "API key for Google service"
      ANTHROPIC_API_URL:
        required: false
        description: "Custom API URL for Anthropic service"
      OPENAI_API_URL:
        required: false
        description: "Custom API URL for OpenAI service"
      GOOGLE_API_URL:
        required: false
        description: "Custom API URL for Google service"
      LLM_BASE_URL:
        required: false
        description: "Base URL for the LLM service"
      MODEL_NAME:
        required: false
        description: "Name of the model to use"
      FORCE_PROVIDER:
        required: false
        description: "Force the use of a specific provider"

permissions:
  pull-requests: write
  issues: write
  contents: read # Keep read for checkout, needs write for potential comment/reaction later

jobs:
  process_comment:
    runs-on: ubuntu-latest
    # Only run on issue comments that are not from bots and contain the command prefix
    if: github.event_name == 'issue_comment' && !contains(github.event.comment.user.login, '[bot]') && contains(github.event.comment.body, inputs.command_prefix)
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}
      context_type: ${{ steps.format.outputs.context_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for git diff base/head comparison

      - name: Install jq, perl and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq perl --no-install-recommends
          gh --version

      # --- Detect Languages ---
      - name: Detect Project Languages
        id: detect_languages
        run: |
          # Initialize flags
          NODE_FOUND=false
          GO_FOUND=false
          RUST_FOUND=false
          PYTHON_FOUND=false

          # Check for dependency files
          if [ -f "package.json" ]; then
            echo "Detected Node.js (package.json)"
            NODE_FOUND=true
          fi
          if [ -f "go.mod" ]; then
            echo "Detected Go (go.mod)"
            GO_FOUND=true
          fi
          if [ -f "Cargo.toml" ]; then
            echo "Detected Rust (Cargo.toml)"
            RUST_FOUND=true
          fi
          if [ -f "requirements.txt" ]; then
            echo "Detected Python (requirements.txt)"
            PYTHON_FOUND=true
          fi

          # Set outputs for use in later steps
          echo "node_found=$NODE_FOUND" >> $GITHUB_OUTPUT
          echo "go_found=$GO_FOUND" >> $GITHUB_OUTPUT
          echo "rust_found=$RUST_FOUND" >> $GITHUB_OUTPUT
          echo "python_found=$PYTHON_FOUND" >> $GITHUB_OUTPUT

      # --- Node.js Setup and Caching (Conditional) ---
      - name: Set up Node.js (Project Deps)
        if: steps.detect_languages.outputs.node_found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm" # Caches ~/.npm based on package-lock.json

      # --- Go Setup and Caching (Conditional) ---
      - name: Set up Go (Project Deps)
        if: steps.detect_languages.outputs.go_found == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"
          # Go caching is automatic in setup-go@v3.2+

      # --- Rust Setup and Caching (Conditional) ---
      - name: Set up Rust (Project Deps)
        if: steps.detect_languages.outputs.rust_found == 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust dependencies (Project Deps)
        if: steps.detect_languages.outputs.rust_found == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # --- Python Setup and Caching (Conditional) ---
      - name: Set up Python (Project Deps)
        if: steps.detect_languages.outputs.python_found == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"
          cache: "pip"
          cache-dependency-path: "**/requirements.txt"

      # --- Install Project Dependencies (Conditional) ---
      - name: Install Project Dependencies
        run: |
          # Node.js - Check for package.json
          if [ "${{ steps.detect_languages.outputs.node_found }}" == "true" ]; then
            echo "Found package.json - Installing Node.js dependencies..."
            npm install || echo "::warning::npm install failed, continuing..."
          fi

          # Go - Check for go.mod
          if [ "${{ steps.detect_languages.outputs.go_found }}" == "true" ]; then
            echo "Found go.mod - Installing Go dependencies..."
            go mod download || echo "::warning::go mod download failed, continuing..."
          fi

          # Rust - Check for Cargo.toml
          if [ "${{ steps.detect_languages.outputs.rust_found }}" == "true" ]; then
            echo "Found Cargo.toml - Building Rust dependencies..."
            cargo build --quiet || echo "::warning::cargo build failed, continuing..."
          fi

          # Python - Check for requirements.txt
          if [ "${{ steps.detect_languages.outputs.python_found }}" == "true" ]; then
            echo "Found requirements.txt - Installing Python dependencies..."
            pip install -r requirements.txt || echo "::warning::pip install failed, continuing..."
          fi

      # --- Node.js setup for probe-chat command itself ---
      - name: Set up Node.js (for probe-chat command)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          # Safety check: Ensure github.event context is as expected
          if [[ -z "${{ github.event.issue.number }}" || -z "${{ github.event.comment.id }}" ]]; then
            echo "::error::Could not get issue number or comment ID from event context."
            exit 1
          fi
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          echo "Context ID (Issue/PR Number): ${{ github.event.issue.number }}, Comment ID: ${{ github.event.comment.id }}"

      - name: Add 'eyes' reaction to comment
        id: add_reaction
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}..."
          gh api --method POST -H "Accept: application/vnd.github+json" "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" -f content='eyes' --silent || echo "::warning::Failed to add 'eyes' reaction."

      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        run: |
          # --- Initialization ---
          echo "::group::Initialization and User Request Extraction"
          shopt -s extglob # Enable extended globbing for string manipulation
          set -e # Exit immediately if a command exits with a non-zero status.
          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json")

          # Trim prefix and leading/trailing whitespace from user request
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          USER_REQUEST_BODY="$USER_REQUEST_BODY_RAW"
          COMMENTS_XML=""
          echo "User request extracted: [${USER_REQUEST_BODY:0:100}...]"
          echo "::endgroup::"

          # --- Determine Context ---
          echo "::group::Determine Context Type"
          CONTEXT_TYPE="issue" # Assume issue by default
          echo "Detecting context for #$ISSUE_OR_PR_NUMBER in $REPO"
          # Try fetching as PR first. If successful, it's a PR.
          if gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER" --jq .url --silent > /dev/null 2>&1; then
             CONTEXT_TYPE="pr"
             echo "Context detected: PR"
          else
             EXIT_CODE=$?
             echo "Not a PR (API check failed with code $EXIT_CODE). Verifying as Issue..."
             # If PR check failed, verify it's an issue (or log warning if both fail)
             if ! gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER" --jq .url --silent > /dev/null 2>&1; then
               ISSUE_EXIT_CODE=$?
               echo "::warning::Issue API check also failed (code $ISSUE_EXIT_CODE). Check permissions or if #$ISSUE_OR_PR_NUMBER exists. Proceeding as 'issue' context."
             else
                echo "Context confirmed: Issue"
             fi
             CONTEXT_TYPE="issue" # Explicitly set back to issue if PR check failed
          fi
          FINAL_CONTEXT_TYPE=$CONTEXT_TYPE
          echo "Final Context Type: $FINAL_CONTEXT_TYPE"
          echo "::endgroup::"

          # --- Fetch Comments and Context Details ---
          echo "::group::Fetch Comments and Context Details"
          # --- Standard Comments (Issue Comments) ---
          echo "Fetching standard comments..."
          STD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")

          if [[ "$STD_COMMENTS_JSON" == "FETCH_FAILED" || -z "$STD_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch standard comments JSON or received empty response."
          else
              # Validate if it's a JSON array before processing
              if echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                  # Process valid JSON array
                  TSV_OUTPUT=$(echo "$STD_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body] | @tsv' 2> jq_std_error.log)
                  JQ_EXIT_CODE=$?
                  if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                      if [[ -n "$TSV_OUTPUT" ]]; then
                          echo "Processing standard comments..."
                          while IFS=$'\t' read -r login created_at body; do
                              [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue # Skip empty lines just in case
                              # Use CDATA to wrap potentially problematic body content
                              COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content><![CDATA[$body]]></content></comment>"
                          done <<< "$TSV_OUTPUT"
                      else
                          echo "Standard comments JSON valid, but no comments found or jq produced empty TSV."
                      fi
                  else
                      echo "::warning::jq failed processing standard comments (exit code $JQ_EXIT_CODE). Error log:"
                      cat jq_std_error.log
                  fi
              else
                  echo "::warning::Fetched standard comments data is not a valid JSON array."
              fi
          fi # End standard comments fetch check
          echo "Standard comments processed. Current XML length: ${#COMMENTS_XML}"

          # --- Context Specific ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$FINAL_CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR specific data..."
            # --- Fetch Base/Head SHAs ---
            echo "Fetching PR base and head SHAs..."
            PR_REFS_JSON=$(gh pr view "$ISSUE_OR_PR_NUMBER" --json baseRefOid,headRefOid --repo "${REPO}" 2> pr_refs_stderr.log || echo "FETCH_FAILED")
            BASE_SHA=""
            HEAD_SHA=""
            if [[ "$PR_REFS_JSON" == "FETCH_FAILED" ]]; then
              echo "::error::Failed to fetch PR SHAs."
              cat pr_refs_stderr.log >&2
              # Allow script to continue, diff will be marked as error later
            else
              BASE_SHA=$(echo "$PR_REFS_JSON" | jq -r .baseRefOid)
              HEAD_SHA=$(echo "$PR_REFS_JSON" | jq -r .headRefOid)
              if [[ -z "$BASE_SHA" || "$BASE_SHA" == "null" || -z "$HEAD_SHA" || "$HEAD_SHA" == "null" ]]; then
                 echo "::error::Could not extract valid base/head SHAs from JSON: $PR_REFS_JSON"
                 BASE_SHA="" # Ensure they are marked as invalid
                 HEAD_SHA=""
                 # Allow script to continue, diff will be marked as error later
              else
                 echo "Base SHA: $BASE_SHA"
                 echo "Head SHA: $HEAD_SHA"
              fi
            fi # End SHA fetch check

            # --- Fetch PR Title/Body ---
            PR_DATA=$(gh pr view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')
            PR_TITLE="Error fetching title" # Default values
            PR_BODY="Error fetching body"
            if [[ "$PR_DATA" == "FETCH_FAILED" ]]; then
              echo "::warning::Failed PR details fetch."
            else
              # Use jq to safely extract, handles nulls gracefully
              PR_TITLE=$(echo "$PR_DATA" | jq -r .title // "Error fetching title")
              PR_BODY=$(echo "$PR_DATA" | jq -r .body // "Error fetching body")
            fi # End PR data fetch check

            # --- Filtered Diff Logic using git diff ---
            echo "Fetching PR diff using git diff with pathspecs..."
            # Define allowed file patterns for git diff pathspec
            ALLOWED_PATTERNS=(
                '*.go'
                '*.js' '*.ts' '*.jsx' '*.tsx'
                '*.rs'
                '*.java'
                '*.c' '*.h' '*.cpp' '*.hpp'
                '*.py'
                '*.cs'
                '*.php'
                '*.rb'
                '*.swift'
                '*.kt' '*.kts'
                '*.scala'
                '*.sh'
                '*.pl' '*.pm'
                '*.lua'
                '*.sql'
                '*.md'
                '*.yaml' '*.yml'
                '*.json'
                # Add non-code files that are useful context
                'Dockerfile'
                'Makefile'
                '.dockerignore'
                '.gitignore'
                'go.mod' 'go.sum'
                'package.json' 'package-lock.json' 'yarn.lock' 'pnpm-lock.yaml'
                'requirements.txt' 'Pipfile' 'Pipfile.lock' 'pyproject.toml' 'poetry.lock'
                'Cargo.toml' 'Cargo.lock'
                'pom.xml' 'build.gradle' 'settings.gradle' 'build.gradle.kts' 'settings.gradle.kts'
                'composer.json' 'composer.lock'
                'Gemfile' 'Gemfile.lock'
                # Config files
                '.*rc' # e.g., .bashrc, .zshrc
                '*.conf'
                '*.cfg'
                '*.ini'
                '*.toml'
                '*.properties'
                # Documentation
                'README.*' # README.md, README.txt etc.
                'LICENSE*'
                'CONTRIBUTING.*'
                'CHANGELOG.*'
                '*.rst'
                '*.adoc'
            )

            RAW_DIFF_CONTENT=""
            GIT_DIFF_EXIT_CODE=1 # Default to error state

            # Check if SHAs were obtained before attempting git diff
            if [[ -z "$BASE_SHA" || -z "$HEAD_SHA" ]]; then
                echo "::error::Cannot run git diff without valid base/head SHAs. Skipping diff generation."
                RAW_DIFF_CONTENT="FETCH_FAILED" # Use this signal to indicate prerequisite failure
            else
                # Use git diff with the fetched SHAs and the allowed patterns
                echo "Running: git diff '${BASE_SHA}...${HEAD_SHA}' -- ${ALLOWED_PATTERNS[*]}" # Debug echo
                # Need to handle potential errors from git diff itself
                set +e # Temporarily disable exit on error for git diff
                git diff "${BASE_SHA}...${HEAD_SHA}" -- "${ALLOWED_PATTERNS[@]}" > raw_diff_output.txt 2> git_diff_stderr.log
                GIT_DIFF_EXIT_CODE=$?
                set -e # Re-enable exit on error
                RAW_DIFF_CONTENT=$(cat raw_diff_output.txt) # Read the output file

                if [[ $GIT_DIFF_EXIT_CODE -ne 0 ]]; then
                    # git diff can return non-zero for various reasons, including actual errors or just no differences found
                    echo "::warning::git diff command exited with code $GIT_DIFF_EXIT_CODE."
                    if [[ -s git_diff_stderr.log ]]; then
                       echo "Stderr from git diff:"
                       cat git_diff_stderr.log
                    fi
                    # If the exit code was non-zero AND the output is empty, treat it as "no changes found" or an error handled below.
                    # If exit code non-zero but output exists, it might be okay (e.g., diff with context lines only?) - proceed cautiously.
                fi

                # Check content regardless of exit code, as 0 means changes found, 1 can mean no changes or error
                if [[ -z "$RAW_DIFF_CONTENT" ]]; then
                   if [[ $GIT_DIFF_EXIT_CODE -eq 0 || $GIT_DIFF_EXIT_CODE -eq 1 ]]; then # Exit code 0 or 1 with no output usually means no relevant diff
                     echo "git diff produced no output for the specified patterns between $BASE_SHA...$HEAD_SHA."
                   else # Non-zero exit code other than 1 with no output is more likely a real error
                     echo "::error::git diff failed (Exit: $GIT_DIFF_EXIT_CODE) and produced no output."
                     RAW_DIFF_CONTENT="FETCH_FAILED" # Signal failure
                   fi
                else
                    echo "git diff successful. Raw diff size: ${#RAW_DIFF_CONTENT} bytes."
                fi
            fi # End SHA check for git diff

            FILTERED_PR_DIFF="" # Initialize variable for filtered diff

            # Check the result of the git diff operation before Perl filtering
            if [[ "$RAW_DIFF_CONTENT" == "FETCH_FAILED" ]]; then
              echo "::warning::Skipping Perl filtering due to previous failure in obtaining git diff."
              FILTERED_PR_DIFF="<!-- Error fetching or generating diff -->"
            elif [[ -z "$RAW_DIFF_CONTENT" ]]; then
              echo "Skipping Perl filtering as git diff produced no relevant content."
              FILTERED_PR_DIFF="<!-- No relevant file changes found for specified patterns -->"
            else
              # Raw diff obtained successfully, now proceed with Perl filtering for minified content etc.
              echo "Raw diff fetched (${#RAW_DIFF_CONTENT} bytes). Filtering suspected minified files..."

              # Pipe the raw diff (from git diff) to Perl
              # Use command substitution carefully
              set +e # Disable exit on error temporarily for the pipe
              FILTERED_PR_DIFF=$(echo "$RAW_DIFF_CONTENT" | perl -ne '
                BEGIN { $chunk = ""; $print_chunk = 1; $max_len = 500; }
                if (/^diff --git a\/(.+)\s+b\/(.+)$/) {
                    print $chunk if $chunk ne "" && $print_chunk;
                    $chunk = $_; $print_chunk = 1; my $b_path = $2;
                    if ($b_path eq "/dev/null") { $print_chunk = 1; }
                    elsif ($b_path =~ m/\.(lock|sum|mod|toml|cfg|ini|properties|yaml|yml|json|md|rst|adoc|txt|conf)$/i ||
                           $b_path =~ m/(Makefile|Dockerfile|LICENSE|README|CONTRIBUTING|CHANGELOG)/i ||
                           $b_path =~ m/\.(gitignore|dockerignore|.*rc)$/ ) { $print_chunk = 1; }
                    elsif (! -e $b_path) { warn "Warning: File $b_path from diff not found at ./$b_path, including chunk."; $print_chunk = 1; }
                    else {
                         if (open my $fh, "<", $b_path) {
                             my $lines_read = 0;
                             while (my $line = <$fh>) {
                                 $lines_read++; chomp $line;
                                 if (length($line) > $max_len && $line !~ m{(https?://\S+|/\S+|[a-zA-Z0-9+/=]{20,}|d="M[\d\.,\sA-Za-z-]+"})}) {
                                     warn "Info: Filtering chunk for $b_path (line $lines_read length > $max_len)"; $print_chunk = 0; last;
                                 }
                                 last if $lines_read >= 3;
                             }
                             close $fh;
                         } else { warn "Warning: Could not open $b_path to check, including chunk."; $print_chunk = 1; }
                    }
                } else { $chunk .= $_; }
                END { print $chunk if $chunk ne "" && $print_chunk; }
              ' 2> filter_stderr.log)
              PERL_PIPE_STATUS=${PIPESTATUS[1]} # Get exit status of perl
              set -e # Re-enable exit on error

              if [[ $PERL_PIPE_STATUS -ne 0 ]]; then
                 echo "::warning::Perl filter script exited with status $PERL_PIPE_STATUS."
                 # Keep the potentially partial output in FILTERED_PR_DIFF, but log warning.
              fi

              if [[ -s filter_stderr.log ]]; then
                 echo "Perl filter script warnings/info:"
                 cat filter_stderr.log
              fi

              # Check result *after* filtering
              if [[ -z "$FILTERED_PR_DIFF" ]] && [[ -n "$RAW_DIFF_CONTENT" ]]; then
                  echo "All diff chunks were filtered out by Perl script."
                  FILTERED_PR_DIFF="<!-- Diff contained only files filtered out by heuristic -->"
              elif [[ -z "$FILTERED_PR_DIFF" ]]; then
                   # This case now covers both "no raw diff" and "raw diff was filtered to nothing"
                   echo "Filtered diff is empty."
                   # Keep the message assigned earlier based on raw diff status
              else
                   echo "Perl filtering complete. Final diff size: ${#FILTERED_PR_DIFF} bytes."
              fi
            fi # End of Perl filtering block check

            # --- Assign Context/Diff XML ---
            # Use CDATA for all potentially multi-line/complex string fields
            CONTEXT_DETAILS_XML="<details><title><![CDATA[$PR_TITLE]]></title><body><![CDATA[$PR_BODY]]></body></details>"
            DIFF_XML="<diff><![CDATA[$FILTERED_PR_DIFF]]></diff>"

            # --- PR Review Comments ---
            echo "Fetching PR review comments..."
            REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")
            if [[ "$REVIEW_COMMENTS_JSON" == "FETCH_FAILED" || -z "$REVIEW_COMMENTS_JSON" ]]; then
                echo "::warning::Failed to fetch PR review comments JSON or received empty response."
            else
                if echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                    TSV_OUTPUT=$(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body, .path // "unknown", .diff_hunk // "", (.line // .original_line // "N/A")] | @tsv' 2> jq_rev_com_error.log)
                    JQ_EXIT_CODE=$?
                    if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                         if [[ -n "$TSV_OUTPUT" ]]; then
                            echo "Processing review comments..."
                            while IFS=$'\t' read -r login created_at body path diff_hunk line; do
                               [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                               # Use CDATA for body and diff_hunk
                               COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$path\" line=\"$line\"><author>$login</author><timestamp>$created_at</timestamp><diff_hunk><![CDATA[$diff_hunk]]></diff_hunk><content><![CDATA[$body]]></content></comment>"
                            done <<< "$TSV_OUTPUT"
                         else
                            echo "Review comments JSON valid, but no comments found or jq produced empty TSV."
                         fi
                    else
                         echo "::warning::jq failed processing review comments (exit code $JQ_EXIT_CODE). Error log:"
                         cat jq_rev_com_error.log
                    fi
                else
                     echo "::warning::Fetched review comments data is not a valid JSON array."
                fi
            fi # End review comments fetch check
            echo "Review comments processed. Current XML length: ${#COMMENTS_XML}"

            # --- PR Reviews (Bodies) ---
            echo "Fetching PR reviews (bodies)..."
            REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate || echo "FETCH_FAILED")
            if [[ "$REVIEWS_JSON" == "FETCH_FAILED" || -z "$REVIEWS_JSON" ]]; then
                 echo "::warning::Failed to fetch PR reviews JSON or received empty response."
            else
                 if echo "$REVIEWS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                     # Filter for reviews with non-empty bodies
                     TSV_OUTPUT=$(echo "$REVIEWS_JSON" | jq -r '.[] | select(.body != null and .body != "") | [.user.login // "unknown", .submitted_at // "N/A", .body, .state // "N/A"] | @tsv' 2> jq_rev_error.log)
                     JQ_EXIT_CODE=$?
                     if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                         if [[ -n "$TSV_OUTPUT" ]]; then
                             echo "Processing review bodies..."
                             while IFS=$'\t' read -r login submitted_at body state; do
                                [[ -n "$login" || -n "$submitted_at" || -n "$body" ]] || continue
                                # Use CDATA for body
                                COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$state\"><author>$login</author><timestamp>$submitted_at</timestamp><content><![CDATA[$body]]></content></comment>"
                             done <<< "$TSV_OUTPUT"
                         else
                             echo "Review JSON valid, but no review bodies with content found or jq produced empty TSV."
                         fi
                     else
                          echo "::warning::jq failed processing review bodies (exit code $JQ_EXIT_CODE). Error log:"
                          cat jq_rev_error.log
                     fi
                 else
                      echo "::warning::Fetched reviews data is not a valid JSON array."
                 fi
            fi # End reviews fetch check
            echo "Review bodies processed. Current XML length: ${#COMMENTS_XML}"

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. The user triggered you via a comment. Analyze the provided PR details (title, body), the conversation history (issue comments, review comments, review summaries), and the code changes (diff). The diff includes changes only for specific file types (code, config, docs) and filters out chunks suspected of being minified based on line length heuristics. Provide a helpful and concise response to the user's request based on this context."

          elif [[ "$FINAL_CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue specific data..."
            # Run gh command, capture output or "FETCH_FAILED" marker
            # Use a different variable name to avoid confusion
            ISSUE_DATA_JSON=$(gh issue view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')

            # Set default shell variables first
            ISSUE_TITLE="Error fetching title"
            ISSUE_BODY="Error fetching body"

            # Check if the fetch succeeded AND returned non-empty data before trying to parse JSON
            if [[ "$ISSUE_DATA_JSON" != "FETCH_FAILED" && -n "$ISSUE_DATA_JSON" ]]; then
              echo "Issue data fetched successfully. Parsing title and body..."
              # Attempt to extract title using jq.
              # Use printf for safer piping. Use -e to set exit code on null.
              # Store extracted value temporarily.
              EXTRACTED_TITLE=$(printf "%s" "$ISSUE_DATA_JSON" | jq -e -r '.title // ""')
              JQ_TITLE_EXIT=$?

              # Overwrite default ONLY if jq succeeded (exit 0) AND extracted value is not empty string
              if [[ $JQ_TITLE_EXIT -eq 0 && -n "$EXTRACTED_TITLE" ]]; then
                  ISSUE_TITLE="$EXTRACTED_TITLE"
              elif [[ $JQ_TITLE_EXIT -eq 0 && -z "$EXTRACTED_TITLE" ]]; then
                   # Handle case where title is explicitly null or empty string in the issue
                   echo "::debug::Issue title is null or empty in fetched data."
                   ISSUE_TITLE="" # Set to empty string
              else
                  # jq failed or returned null (which -e treats as exit code 10)
                  echo "::warning::jq failed to extract issue title (exit code $JQ_TITLE_EXIT) or value was null. Using default."
                  # Default is already set, no action needed
              fi

              # Attempt to extract body using jq.
              EXTRACTED_BODY=$(printf "%s" "$ISSUE_DATA_JSON" | jq -e -r '.body // ""')
              JQ_BODY_EXIT=$?

              # Overwrite default ONLY if jq succeeded (exit 0) AND extracted value is not empty string
              if [[ $JQ_BODY_EXIT -eq 0 && -n "$EXTRACTED_BODY" ]]; then
                  ISSUE_BODY="$EXTRACTED_BODY"
              elif [[ $JQ_BODY_EXIT -eq 0 && -z "$EXTRACTED_BODY" ]]; then
                   # Handle case where body is explicitly null or empty string in the issue
                   echo "::debug::Issue body is null or empty in fetched data."
                   ISSUE_BODY="" # Set to empty string
              else
                   # jq failed or returned null
                  echo "::warning::jq failed to extract issue body (exit code $JQ_BODY_EXIT) or value was null. Using default."
                  # Default is already set, no action needed
              fi
            else
              # This block runs if gh command failed OR returned empty string
              echo "::warning::Failed Issue details fetch (gh command failed or returned empty). Using default title/body."
              # Defaults are already set, no action needed here
            fi # End issue data JSON parsing check

            # --- Assign Context/Diff XML ---
            # Use CDATA for all potentially multi-line/complex string fields
            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML="" # No diff for issues
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. The user triggered you via a comment. Analyze the provided issue details (title, body) and the conversation history (comments). Provide a helpful and concise response to the user's request based on this context."
          fi # End PR/Issue context specific block

          echo "::endgroup::"

          # --- Assemble Final Prompt ---
          echo "::group::Assemble Final Prompt & Set Outputs"
          # Ensure variables are properly escaped for use in XML attributes if needed, though login/timestamp are usually safe
          USER_LOGIN="${{ github.event.comment.user.login }}"
          TIMESTAMP="${{ github.event.comment.created_at }}"

          # Assemble the prompt using CDATA where needed
          # Ensure the variables themselves are expanded correctly by the shell
          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>${COMMENTS_XML}</comments>
            <user_request author=\"${USER_LOGIN}\" timestamp=\"${TIMESTAMP}\"><![CDATA[${USER_REQUEST_BODY}]]></user_request>
            </github_context>
            
            <instructions><![CDATA[${PROMPT_INSTRUCTION}]]></instructions>"

          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then
            echo "::warning::Formatted prompt seems very short (${#FORMATTED_PROMPT} bytes). Ensure context fetching worked."
          fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT} bytes."

          PROMPT_FILENAME="formatted_prompt.txt"
          echo "$FORMATTED_PROMPT" > "$PROMPT_FILENAME"
          echo "Prompt written to $PROMPT_FILENAME"

          echo "Setting step outputs..."
          echo "context_type=${FINAL_CONTEXT_TYPE}" >> "$GITHUB_OUTPUT"
          echo "formatted_prompt_file=${PROMPT_FILENAME}" >> "$GITHUB_OUTPUT"
          echo "Outputs set."
          echo "::endgroup::"
          # IMPORTANT: set +e was removed earlier, ensure script exits correctly on error or succeeds
          # Script implicitly ends here

      - name: Determine probe-chat command
        id: determine_command
        env:
          PROBE_CHAT_COMMAND_SECRET: ${{ secrets.PROBE_CHAT_COMMAND }}
        run: |
          COMMAND_VAR=""
          if [[ -n "${PROBE_CHAT_COMMAND_SECRET}" ]]; then
            echo "Using PROBE_CHAT_COMMAND secret."
            COMMAND_VAR="${PROBE_CHAT_COMMAND_SECRET}"
          else
            echo "Using default_probe_chat_command input: ${{ inputs.default_probe_chat_command }}"
            COMMAND_VAR="${{ inputs.default_probe_chat_command }}"
          fi

          if [[ -z "$COMMAND_VAR" ]]; then
             echo "::error::Command is empty after evaluation. Check secrets/inputs."
             exit 1
          fi

          echo "Determined command base: $COMMAND_VAR"
          echo "command=$COMMAND_VAR" >> "$GITHUB_OUTPUT"

      - name: Run probe-chat
        id: probe
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          set -o pipefail # Fail pipe if any command fails
          PROMPT_FILE="${{ steps.format.outputs.formatted_prompt_file }}"
          COMMAND_BASE="${{ steps.determine_command.outputs.command }}"
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
          COMMAND_TO_RUN="$COMMAND_BASE" # Start building command

          # Add prompt type based on context
          CONTEXT_TYPE="${{ steps.format.outputs.context_type }}"
          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            COMMAND_TO_RUN="$COMMAND_TO_RUN --prompt code-review"
            echo "Using code-review prompt for pull request context"
          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            COMMAND_TO_RUN="$COMMAND_TO_RUN --prompt support"
            echo "Using support prompt for issue context"
          else
            echo "::warning:: Unknown context type '$CONTEXT_TYPE', not adding specific prompt flag."
          fi

          if [[ -z "$COMMAND_TO_RUN" ]]; then
            echo "::error::COMMAND_TO_RUN is unexpectedly empty after building!" >&2
            echo "ðŸ¤– **Error:** Internal configuration error - AI command is missing." > "$RESPONSE_FILE"
            exit 1
          fi

          if [ ! -s "$PROMPT_FILE" ]; then
            echo "::error::Prompt file '$PROMPT_FILE' not found or is empty. Check 'format' step logs." >&2
            echo "ðŸ¤– **Error:** Internal error - prompt file missing or empty." > "$RESPONSE_FILE"
            exit 1
          fi

          echo "Prompt file: $PROMPT_FILE"
          echo "Prompt file size: $(wc -c < "$PROMPT_FILE") bytes"
          echo "Command to run: $COMMAND_TO_RUN"
          echo "Running probe-chat..."

          # Pipe prompt content to command stdin, capture stdout/stderr
          cat "$PROMPT_FILE" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG"
          EXIT_CODE=${PIPESTATUS[1]} # Get exit code of $COMMAND_TO_RUN

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE." >&2
            if [ -s "$ERROR_LOG" ]; then
              echo "--- probe-chat stderr ---" >&2
              cat "$ERROR_LOG" >&2
              echo "--- end probe-chat stderr ---" >&2
            fi
            # If response file empty, write a generic error
            if [ ! -s "$RESPONSE_FILE" ]; then
               echo "ðŸ¤– **Error:** AI command failed (Exit code: $EXIT_CODE). Check Action logs." > "$RESPONSE_FILE"
            fi
             # Let workflow continue to reporting step
          else
            echo "probe-chat command finished successfully (Exit code: 0)."
          fi

          # Check for empty response on success
          if [ $EXIT_CODE -eq 0 ] && [ ! -s "$RESPONSE_FILE" ]; then
            echo "::warning::probe-chat command succeeded but produced an empty response."
            echo "ðŸ¤– AI command ran successfully but generated no response." > "$RESPONSE_FILE"
          fi

      - name: Read Response or Error and Format Output
        if: always() # Run always to report status
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          ERROR_LOG_CONTENT=$(cat error.log 2>/dev/null || echo "")
          FINAL_BODY=""
          FOOTER_TEMPLATE="\n\n-----\n*Tip: Mention me again using \`%s <request>\`.*\n*Powered by [Probe AI](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX"

          # Check the outcome of the 'probe' step
          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
            if [[ -n "${RESPONSE_CONTENT// }" ]]; then # Check if not empty or just whitespace
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
            else
              # Probe succeeded but response file was empty (handled in probe step)
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}" # Use the message written in probe step
            fi
          else
            # Probe step failed or earlier steps failed
            ERROR_MESSAGE="ðŸ¤– **Error:** AI interaction failed."
            if [[ "${{ steps.format.outcome }}" == "failure" ]]; then
              ERROR_MESSAGE="ðŸ¤– **Error:** Failed during context preparation. Check 'Format Input' logs."
            elif [[ "${{ steps.probe.outcome }}" == "failure" ]]; then
                # Prefer error message from response.txt if it looks like an error
                if [[ -n "${RESPONSE_CONTENT// }" ]] && echo "$RESPONSE_CONTENT" | grep -q -E "(Error:|ERROR:|Failed|failed|Cannot|Could not)"; then
                   ERROR_MESSAGE="${RESPONSE_CONTENT}" # Use the error from response.txt
                else
                   # Fallback to generic message + stderr if available
                   ERROR_MESSAGE="ðŸ¤– **Error:** The AI command failed to execute or returned an error."
                   if [[ -n "${ERROR_LOG_CONTENT// }" ]]; then
                     ERROR_DETAILS=$(head -c 1000 <<< "$ERROR_LOG_CONTENT")
                     if [[ ${#ERROR_LOG_CONTENT} -gt 1000 ]]; then ERROR_DETAILS="${ERROR_DETAILS}\n...(truncated)"; fi
                     ERROR_MESSAGE="${ERROR_MESSAGE}\n\n**Details (stderr):**\n\`\`\`\n${ERROR_DETAILS}\n\`\`\`"
                   else
                     ERROR_MESSAGE="${ERROR_MESSAGE} Check 'Run probe-chat' logs."
                   fi
                fi
            else # Other preceding failure
              ERROR_MESSAGE="ðŸ¤– **Error:** Workflow failed before AI interaction. Check logs."
            fi
            FINAL_BODY="${ERROR_MESSAGE}${FOOTER}"
          fi

          echo "Final response body prepared. Length: ${#FINAL_BODY}"
          {
            echo "response<<EOF_RESPONSE_MARKER"
            echo "$FINAL_BODY"
            echo "EOF_RESPONSE_MARKER"
          } >> "$GITHUB_OUTPUT"

  post_response:
    if: always() && needs.process_comment.result != 'skipped' # Run if process_comment ran, even if it failed
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
          reactions: ${{ needs.process_comment.outputs.probe_succeeded == 'true' && '+1' || '-1' }}

# </gh>
