#!/usr/bin/env node

import { spawn } from 'child_process';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { access, constants } from 'fs';
import { promisify } from 'util';

const accessAsync = promisify(access);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Check if a file exists and is executable
 */
async function isExecutable(filePath) {
  try {
    await accessAsync(filePath, constants.F_OK | constants.X_OK);
    return true;
  } catch {
    return false;
  }
}

/**
 * Attempt to download the binary if it's missing
 */
async function ensureBinary(binaryPath) {
  try {
    // Try to import the downloader and download the binary
    const { downloadProbeBinary } = await import('../src/downloader.js');
    console.log('Probe binary not found, downloading...');
    await downloadProbeBinary();
    
    // Check if the binary now exists and is executable
    if (await isExecutable(binaryPath)) {
      console.log('Binary downloaded successfully.');
      
      // On macOS, try to remove quarantine attributes that might prevent execution
      if (process.platform === 'darwin') {
        try {
          const { exec } = await import('child_process');
          const { promisify } = await import('util');
          const execAsync = promisify(exec);
          await execAsync(`xattr -d com.apple.quarantine "${binaryPath}" 2>/dev/null || true`);
        } catch {
          // Ignore errors - this is just a precaution
        }
      }
      
      return true;
    } else {
      console.error('Binary downloaded but is not executable.');
      return false;
    }
  } catch (error) {
    console.error('Failed to download binary:', error.message);
    return false;
  }
}

/**
 * Spawn the probe binary with proper error handling
 */
async function spawnProbeBinary(binaryPath, args) {
  return new Promise((resolve, reject) => {
    const child = spawn(binaryPath, args, { stdio: 'inherit' });
    
    child.on('error', async (error) => {
      // Handle spawn errors, particularly the dreaded "spawn Unknown system error -8"
      if (error.code === 'ENOENT') {
        console.error(`Error: Binary not found at ${binaryPath}`);
        process.exit(1);
      } else if (error.code === 'EACCES' || error.message.includes('spawn') || error.errno === -8) {
        console.error(`Error: Cannot execute binary at ${binaryPath}`);
        console.error('This might be due to:');
        console.error('1. Missing execute permissions');
        console.error('2. Architecture mismatch');
        console.error('3. Corrupted binary file');
        console.error('');
        console.error('Attempting to re-download the binary...');
        
        const downloadSuccess = await ensureBinary(binaryPath);
        if (downloadSuccess) {
          // Retry execution after download
          try {
            const retryChild = spawn(binaryPath, args, { stdio: 'inherit' });
            retryChild.on('exit', (code) => resolve(code || 0));
            retryChild.on('error', (retryError) => {
              console.error('Failed to execute binary even after re-download:', retryError.message);
              reject(retryError);
            });
          } catch (retryError) {
            console.error('Failed to retry execution:', retryError.message);
            reject(retryError);
          }
        } else {
          reject(error);
        }
      } else {
        console.error('Unexpected error:', error.message);
        reject(error);
      }
    });
    
    child.on('exit', (code) => resolve(code || 0));
  });
}

// Main execution logic
async function main() {
  try {
    // Check if first argument is 'mcp'
    if (process.argv[2] === 'mcp') {
      // Launch MCP server instead of binary
      const mcpPath = join(__dirname, '..', 'build', 'mcp', 'index.js');
      const mcpArgs = process.argv.slice(3); // Remove 'node', 'probe', and 'mcp'
      
      const child = spawn('node', [mcpPath, ...mcpArgs], { stdio: 'inherit' });
      child.on('exit', (code) => process.exit(code || 0));
    } else if (process.argv[2] === 'agent') {
      // Launch Agent server instead of binary
      const agentPath = join(__dirname, '..', 'src', 'agent', 'index.js');
      const agentArgs = process.argv.slice(3); // Remove 'node', 'probe', and 'agent'
      
      const child = spawn('node', [agentPath, ...agentArgs], { stdio: 'inherit' });
      child.on('exit', (code) => process.exit(code || 0));
    } else {
      // Normal probe binary execution
      const isWindows = process.platform === 'win32';
      const binaryName = isWindows ? 'probe.exe' : 'probe-binary';
      const binaryPath = join(__dirname, binaryName);
      
      // Check if binary exists and is executable
      if (!(await isExecutable(binaryPath))) {
        console.log('Probe binary not found or not executable, attempting to download...');
        const downloadSuccess = await ensureBinary(binaryPath);
        if (!downloadSuccess) {
          console.error('Failed to download probe binary. Please try installing again or check your internet connection.');
          process.exit(1);
        }
      }
      
      // Execute the binary
      const exitCode = await spawnProbeBinary(binaryPath, process.argv.slice(2));
      process.exit(exitCode);
    }
  } catch (error) {
    console.error('Unexpected error in probe wrapper:', error.message);
    process.exit(1);
  }
}

// Run the main function
main().catch(error => {
  console.error('Fatal error:', error.message);
  process.exit(1);
});